> #### 目录
>
> > <a href='#one'>软件测试的目的和原则</a>
> >
> > > > <a href='#one_first'>软件测试的目的</a>
> > > 
> > > > <a href='#one_second'>软件测试的原则</a>
> > > 
> > > > <a href='#one_third'>软件测试对象</a>
> > > 
> > > > <a href='#one_fourth'>测试信息流</a>
> > > 
> > > > <a href='#one_fifth'>测试与软件开发各阶段的关系</a>
> >
> > <a href='#two'>软件测试用例设计</a>
> >
> > > > <a href='#two_first'>黑盒测试</a>
> > >
> > > > <a href='#two_second'>白盒测试</a>
> > >
> > > > <a href='#two_third'>逻辑覆盖</a>
> > >
> > > > > > <a href='#two_third_one'>语句覆盖</a>
> > > > >
> > > > > > <a href='#two_third_two'>判定覆盖</a>
> > > > >
> > > > > > <a href='#two_third_three'>条件覆盖</a>
> > > > >
> > > > > > <a href='#two_third_four'>判定-条件覆盖</a>
> > > > >
> > > > > > <a href='#two_third_five'>条件组合覆盖</a>
> > > > >
> > > > > > <a href='#two_third_six'>路径覆盖</a>
> > > > >
> > > > > > <a href='#two_third_seven'>条件测试路径选择</a>
> > > > >
> > > > > > <a href='#two_third_eight'>循环测试路径选择</a>
> > > > > >
> > > > > > > 简单循环
> > > > > > >
> > > > > > > 嵌套循环
> > > > > > >
> > > > > > > 连锁循环
> > > > > > >
> > > > > > > 非结构循环
> > > > >
> > > > > > <a href='#two_third_nine'>基本路径测试</a>
> > > > > >
> > > > > > > 程序的控制流图
> > > > > > >
> > > > > > > 程序环路复杂性
> > > > > > >
> > > > > > > 导出测试用例
> > > > > >
> > > > > > <a href='#two_third_ten'>黑盒测试的测试用例设计</a>
> > > > > >
> > > > > > > <a href='#two_third_ten_one'>等价类划分</a>
> > > > > > >
> > > > > > > <a href='#two_third_ten_two'>边界值分析</a>
> > > > > > >
> > > > > > > <a href='#two_third_ten_three'>错误推测法</a>
> > > > > > >
> > > > > > > <a href='#two_third_ten_four'>因果图</a>
> >
> > <a href='#three'>软件测试策略</a>
> >
> > <a href='#four'>软件测试种类</a>
> >
> > <a href='#five'>程序调试</a>



### <a name='one'><i style='color:blue'>软件测试的目的和原则</i></a>

- #### <a name='one_first'><u><i>软件测试的目的</i></u></a>

  - ##### 基于不同的立场，存在着两种完全不同的测试目的
    
    - 从<span style='color:red;'><b>用户的角度</b></span>出发，普遍希望通过软件测试<span style='color:red;'><b>暴露软件中隐藏的错误和缺陷</b></span>，以考虑是否可以接受该产品
    - 从<span style='color:red;'><b>软件开发者</b></span>的角度出发，则希望测试成为<span style='color:red;'><b>表明软件产品中不存在错误</b></span>的过程，验证该软件已正确地实现了用户的要求，确立人们对软件质量的信息。
  - ##### Myers软件测试目的
    
    - 测试是<span style='color:blue;'><b>程序的执行过程</b></span>，目的在于<span style='color:blue;'><b>发现错误</b></span>
    - 一个好的测试用例在于<span style='color:blue;'><b>能发现至今未发现的错误</b></span>
    - 一个成功的测试是<span style='color:blue;'><b>发现了至今未发现的错误</b></span>
  - ##### 换言之，测试的目的是
    
    - 想以最少的时间和人力，<span style='color:red;'><b>系统地找出软件中潜在的各种错误和缺陷</b></span>。如果我们成功地实施了测试，我们就能够发现软件中的错误
    - 测试的附带收获是，它<span style='color:red;'><b>能够证明软件的功能和性能与需求说明相符合</b></span>
    - 实施测试收集到的测试结果数据为可靠性分析提供了数据
    - <span style='color:red;'><b>测试不能表明软件中不存在错误，它只能说明软件中存在错误</b></span>

  

- #### <a name='one_second'><u><i>软件测试的原则</i></u></a>

  1. 应当把’<span style='color:red;'><b>尽早地和不断地进行软件测试</b></span>‘作为软件开发者的座右铭

  2. 测试用例应由<span style='color:red;'><b>测试输入数据</b></span>和对应的<span style='color:red;'><b>预期输出结果</b></span>这两部分组成

  3. 程序员应避免检查自己的程序

  4.  在设计测试用例时，应包括<span style='color:blue;'><b>合理的输入条件</b></span>和<span style='color:blue;'><b>不合理的输入条件</b></span>

  5. 充分注意测试中的群集现象，
     经验表明，<span style='color:red;'><b>测试后程序中残存的错误数目与该程序中已发现的错误数目成正比</b></span>

  6. 严格执行测试计划，排除<span style='color:#009AFF;'><b>测试的随意性</b></span>

  7. 应当对每一个测试结果做全面检查

  8. 妥善保存测试计划，测试用例，出错统计和最终分析报告，为维护提供方便

  

- #### <a name='one_third'><u><i>软件测试的对象</i></u></a>

  - 软件测试并不等于程序测试。<span style='color:red;'><b>软件测试应贯穿于软件定义与开发的整个期间</b></span>
  - <span style='color:blue;'><b>需求分析、概要设计、详细设计以及程序编码</b></span>等各阶段所得到的文档，包括需求规格说明、概要设计规格说明、详细设计规格说明以及源程序，<span style='color:blue;'><b>都应成为软件测试的对象</b></span>
  - 为把握软件开发各个环节的正确性，需要进行各种<span style='color:red;'><b>确认</b></span>和<span style='color:red;'><b>验证</b></span>工作
  - <span style='color:red;'><b>确认</b></span>，是一系列的活动和过程，目的是想证实在一个给定的外部环境中软件的逻辑正确性
    - <span style='color:blue;'><b>需求规格说明确认</b></span>
    - <span style='color:blue;'><b>程序确认（静态确认、动态确认）</b></span>
  - <span style='color:red;'><b>验证</b></span>，试图证明在软件生存期各个阶段，以及阶段间的逻辑协调性、完备性和正确性
  - <img src='/图片/1.jpg'>

  

- #### <a name='one_fourth'><u><i>测试信息流</i></u></a>

  - <img src='/图片/2.jpg'>

  - ##### 软件配置：

    - 软件需求规格说明、软件设计规格说明、源代码等

  - ##### 测试配置：

    - 测试计划、测试用例、测试程序等

  - ##### 测试工具：

    - 测试数据自动生成程序、静态分析程序、动态分析程序、测试结果分析程序、以及驱动测试的测试数据库等等

  - ##### 测试结果分析：

    - 比较实测结果与预期结果，评价错误是否发生。

  - ##### 排错（调试）：

    - 对已经发现的错误进行错误定位和确定出错性质，并改正这些错误，同时修改相关的文档

  - ##### 修正后的文档在测试：直到通过测试为止。

  - ##### 通过收集和分析测试结果数据，对软件建立可靠性模型

  - ##### 利用可靠性分析，评价软件质量：

    - <span style='color:blue;'><b>软件的质量和可靠性达到可以接受的程度</b></span>
    - <span style='color:blue;'><b>所做的测试不足以发现严重的错误</b></span>

  - ##### 如果测试发现不了错误，可以肯定，测试配置考虑得不够细致充分，错误仍然潜伏在软件中

  

- #### <a name='one_fifth'><u><i>测试与软件开发各阶段的关系</i></u></a>

  - 软件开发过程是一个自顶向下，逐步细化的过程
  - 软件计划阶段定义软件作用域
  - 软件需求分析建立软件信息域、功能和性能需求、约束等
  - 软件设计
  - 把设计用某种程序设计语言转换成程序代码
  - 测试过程是以相反顺序安排的自底向上，逐步集成的过程
  - <img src='/图片/3.jpg'>



### <a name='two'><i style='color:blue'>软件测试用例设计</i></a>

- #### 两种常用的测试方法

  - #### <a name='two_first'><i><u>黑盒测试</u></i></a>

    - ##### 这种方法是把测试对象看作一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明

    - ##### 黑盒测试又叫做功能测试或数据驱动测试

    - ##### 黑盒测试的优点：

      1. 基本上不用人管着，如果程序停止运行了一般就是被测试程序crash了
      2. 设计完测试例后，下来的工作就是爽了，当然更苦闷的是确定crash原因

    - ##### 黑盒测试的缺点：

      1. 结果取决于测试例的设计，测试例的设计部分来源于经验，**OUSPG**的东西很值得借鉴

      2. 没有状态转换的概念，一些成功的例子基本上都是针对**PDU**来做的，还做不到针对被测试程序的状态转换来做

         ```
         协议数据单元，是指在分层网络结构，例如在开放式系统互联（OSI）模型中，在传输系统的每一层都将建立协议数据单元（PDU）。
         
         SNMP规定了5种协议数据单元PDU（也就是SNMP报文），用来在管理进程和代理之间的交换。
         	get-request操作：从代理进程处提取一个或多个参数值
         	get-next-request操作：从代理进程处提取紧跟当前参数值的下一个参数值
         	set-request操作：设置代理进程的一个或多个参数值
         	get-response操作：返回的一个或多个参数值。这个操作是由代理进程发出的，它是前面三种操作的响应操作。
         	trap操作：代理进程主动发出的报文，通知管理进程有某些事情发生。
         
         前面的3种操作是由管理进程向代理进程发出的，后面的2个操作是代理进程发给管理进程的，为了简化起见，前面3个操作今后叫做get、get-next和set操作。
         
         注意：在代理进程端是用熟知端口161俩接收get或set报文，而在管理进程端是用熟知端口162来接收trap报文。
         ```

      3. 就没有状态概念的测试来说，寻找和确定造成程序crash的测试例是个麻烦事情，必须把周围可能的测试用例单独确认一遍。而有的状态的测试来说，就更麻烦了，尤其不是一个单独的testcase造成的问题。这些在堆的问题中表现得更为突出

    - ##### 黑盒测试方法是在程序接口上进行测试，主要是为了发现以下错误：

      1. 是否有不正确或遗漏了的功能？
      2. 在接口上，输入能否正确地接受？能否输出正确的结果？
      3. 是否有数据结构错误 或外部信息（例如数据文件）访问错误？
      4. 性能上是否能够满足要求？
      5. 是否有初始化或终止性错误？

    - ##### 用黑盒测试发现程序中的错误，必须在所有可能的输入条件和输出条件中确定测试数据，来检查程序是否都能产生正确的输出

    - ##### 但这是<span style='color:red'>**不可能**</span>的

      <img src='/图片/4.jpg'>

    

  - #### <a name='two_second'><u><i>白盒测试</i></u></a>

    - ##### 优点：
  
      1. 迫使测试人员去仔细思考软件的实现
      2. 可以检测代码中的每条分支和路径
      3. 揭示隐藏在代码中的错误
    4. 对代码的测试比较彻底
      5. 让软件最优化

    - ##### 缺点：
  
      1. 昂贵
    2. 无法检测代码中遗漏的路径和数据敏感性错误
      3. 不验证规格的正确性

    - 此方法把测试对象看作一个透明的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试

    - 通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致。因此白盒测试又称为结构测试或逻辑驱动测试。

    - ##### 软件人员使用白盒测试方法，主要相对程序模块进行如下的检查：
  
      1. 对程序的模块的所有独立的执行路径至少测试一次
      2. 对所有的逻辑判定，取‘真’与取‘假’的两种情况都至少测试一次
      3. 在循环的边界和运行界限内执行循环体
      4. 测试内部数据结构的有效性等
    5. 对一个具有多重选择和循环嵌套的程序，不同的路径数目可能是天文数字。给出一个小程序的流程图，它包括了一个执行20次的循环
      6. 有些路径要想把所有路径测完需要很久很久
    
      
  
  - #### <a name='two_third'><u><i>逻辑覆盖</i></u></a>
  
    - 逻辑覆盖是以<span style='color:red'>**程序内部的逻辑结构**</span>为基础的设计测试用例的技术。它属<span style='color:red'>**白盒测试**</span>
  
      - ##### 例:
  
        <img src='/图片/5.jpg'>
  
        1. a-->c-->e
  
           ```
           a>1 and b=0 t  
           a=2 or x/a>1 t
           合并：
           a>1 and b=0 and a=2 or x/a>1
           分析：
           a>1 and b=0 and a=2
           a>1 and b=0 and x/a>1
           结果（两种）:
           a=2 and b=0
           a>1 and b=0 and x/a>1
           ```
  
        2. a-->b-->d
  
           ```
           a>1 and b=0  f -->  not(a>1) or not(b=0) t
           a=2 or x/a>1   f -->  not(a=2) and not(x/a>1) t
           合并:
           not(a>1) or not(b=0) and not(a=2) and not(x/a>1)
           分析：
           not(a>1) and not(a=2) and not(x/a>1) --> a<=1 and x/a<=1
           not(b=0) and not(a=2) and not(x/a>1) --> b!=0 and a!=2 and x/a<=1
           结果(两种):
           a<=1 and x/a<=1
           b!=0 and a!=2 and x/a<=1
           ```
  
        3. a-->c-->d
  
           ```
           a>1 and b=0 t
           a=2 or x/a>1  f --> not(a=2) and not(x/a>1)  t 
           合并:
           a>1 and b=0 and not(a=2) and not(x/a>1)
           分析:
           a>1 and b=0 and not(a=2) and not(x/a>1) --> a>1 and a!=2 and b=0 and x/a<=1
           结果（一种）:
           a>1 and a!=2 and b=0 and x/a<=1
           ```
  
        4. a-->b-->e
  
           ```
           a>1 and b=0 f  --> not(a>1) or not(b=0)
           a=2 or x/a>1  t 
           合并：
           not(a>1) or not(b=0) and a=2 or x/a>1
           分析:
           not(a>1) and a=2  --> 不存在这种可能
           not(a>1) and x/a>1  --> a<=1 and x/a>1
           not(b=0) and a=2  --> b!=0 and a=2
           not(b=0) and x/a>1  --> b!=0 and x/a>1
           结果（三种）：
           a<=1 and x/a>1
           b!=0 and a=2
           b!=0 and x/a>1
           ```
  
        
  
      - ##### <span style='color:blue'><a name='two_third_one'>语句覆盖</a></span>
  
        - 语句覆盖就是设计若干个测试用例，运行被测程序。使得每一可执行语句至少执行一次
  
        - 在下图例中，正好所有的可执行语句都在路径**ace**上，所以选择路径**ace**设计测试用例，就可以覆盖所有的可执行语句
  
        - 测试用例的设计格式如下
  
          【输入的（A,B,X）,输出的（A,B,X）】
  
        - 为图例设计满足语句覆盖的测试用例是：
  
          【（2，0，4），（2，0，3）】
  
          覆盖**ace**两种可能的 条件
  
          ```
          a=2 and b=0
          a>1 and b=0 and x/a>1
          ```
  
        
  
      - ##### <span style='color:blue'><a name='two_third_two'>判定覆盖</a></span>
  
        - 判定覆盖就是设计若干个测试用例，运行被测程序，使得程序中每个判断的取真分支和取假分支至少经历一次
  
        - 判定覆盖又称为分支覆盖
  
        - 对于图例，如果选择路径**ace**和**abd**，就可以满足要求的测试用例：
  
          【输入（a,b,x），输出（a,b,x）】：
  
          【（2，0，4），（2，0，3）】覆盖**ace  **
  
          ```
          a=2 and b=0
          a>1 and b=0 and x/a>1
          ```
  
          【（1，1，1），（1，1，1）】覆盖**abd  **
  
          ```
          a<=1 and x/a<=1
          b!=0 and a!=2 and x/a<=1
          ```
  
        - 如果选择路径**abe**和**acd**，还可得另一组可用的测试用例：
  
          【输入（a,b,x），输出（a,b,x）】：
  
          【（2，1，1），（2，1，2）】覆盖**abe **
  
          ```
          a<=1 and x/a>1
          b!=0 and a=2
          b!=0 and x/a>1
          ```
  
          【（3，0，3），（3，1，1）】覆盖**acd **
  
          ```
          a>1 and a!=2 and b=0 and x/a<=1
          ```
  
        
  
      - ##### <span style='color:blue'><a name='two_third_three'>条件覆盖</a></span>
  
        - 条件覆盖就是设计若干个测试用例，运行被测程序，使得程序中每个判断的每个条件的可能取值至少执行一次
  
        - 在图例中，我们事先可对所有条件的取值加以标记，例如
  
          对于第一个判断：
  
          - 条件a>1取真为<span style='color:green'>**t1**</span>，取假为<span style='color:red'>**f1**</span>
  
            条件b=0取真为<span style='color:green'>**t2**</span>，取假为<span style='color:red'>**f2**</span>
  
          对于第二个判断
  
          - 条件a=2取真为<span style='color:green'>**t3**</span>，取假为<span style='color:red'>**f3**</span>
  
            条件x>1取真为<span style='color:green'>**t4**</span>，取假为<span style='color:red'>**f4**</span>
  
            | 测试用例                     | 覆盖分支 | 条件取值                                                     |
            | ---------------------------- | -------- | ------------------------------------------------------------ |
            | 【（2，0，4），（2，0，3）】 | c,e      | <span style='color:green'>t1</span>,<span style='color:green'>t2</span>,<span style='color:green'>t3</span>,<span style='color:green'>t4</span> |
            | 【（1，0，1），（1，0，1）】 | b,d      | <span style='color:red'>f1</span>,<span style='color:green'>t2</span>,<span style='color:red'>f3</span>,<span style='color:red'>f4</span> |
            | 【（2，1，1），（2，1，2）】 | b,e      | <span style='color:green'>t1</span>,<span style='color:red'>f2</span>,<span style='color:green'>t3</span>,<span style='color:red'>f4</span> |
  
            或
  
            | 测试用例                     | 覆盖分支 | 条件取值                                                     |
            | ---------------------------- | -------- | ------------------------------------------------------------ |
            | 【（1，0，3），（1，0，4）】 | b,e      | <span style='color:red'>f1</span>,<span style='color:green'>t2</span>,<span style='color:red'>f3</span>,<span style='color:green'>t4</span> |
            | 【（2，1，1），（2，1，2）】 | b,e      | <span style='color:green'>t1</span>,<span style='color:red'>f2</span>,<span style='color:green'>t3</span>,<span style='color:red'>f4</span> |
  
            
  
      - ##### <span style='color:blue'><a name='two_third_four'>判定-条件覆盖</a></span>
  
        - 判定-条件覆盖就是设计足够的测试用例，使得<span style='color:red'>**判断中每个条件的所有可能取值至少执行一次，每个判断中的每个条件的可能取值至少执行一次。**</span>
  
          | 测试用例                     | 覆盖分支 | 条件取值                                                     |
          | ---------------------------- | -------- | ------------------------------------------------------------ |
          | 【（2，0，4），（2，0，3）】 | c,e      | <span style='color:green'>t1</span>,<span style='color:green'>t2</span>,<span style='color:green'>t3</span>,<span style='color:green'>t4</span> |
          | 【（1，1，1），（1，1，1）】 | b,d      | <span style='color:red'>f1</span>,<span style='color:red'>f2</span>,<span style='color:red'>f3</span>,<span style='color:red'>f4</span> |
  
          <img src='/图片/6.jpg'>
  
        
  
      - ##### <span style='color:blue'><a name='two_third_five'>条件组合覆盖</a></span>
  
        - 条件组合覆盖就是设计足够的测试用例，运行被测程序，使得<span style='color:red'>**每个判断的所有可能的条件取值组合至少执行一次**</span>
  
        - 即：
  
          1. a>1,b=0    --> <span style='color:green'>t1</span>,<span style='color:green'>t2</span>
          2. a>1,b!=0   --> <span style='color:green'>t1</span>,<span style='color:red'>f2</span>
          3. a<=1,b=0  --> <span style='color:red'>f1</span>,<span style='color:green'>t2</span>
          4. a<=1,b!=0 --> <span style='color:red'>f1</span>,<span style='color:red'>f2</span>
          5. a=2,x>1    --> <span style='color:green'>t3</span>,<span style='color:green'>t4</span>
          6. a=2,x<=1  --> <span style='color:green'>t3</span>,<span style='color:red'>f4</span>
          7. a!=2,x>1   --> <span style='color:red'>f3</span>,<span style='color:green'>t4</span>
          8. a!=2,x<=1 --> <span style='color:red'>f3</span>,<span style='color:red'>f4</span>
  
          | 测试用例                     | 覆盖条件                                                     | 覆盖组合 |
          | ---------------------------- | ------------------------------------------------------------ | -------- |
          | 【（2，0，4），（2，0，3）】 | <span style='color:green'>t1</span>,<span style='color:green'>t2</span>,<span style='color:green'>t3</span>,<span style='color:green'>t4</span> | 1，5     |
          | 【（2，1，1），（2，1，2）】 | <span style='color:green'>t1</span>,<span style='color:red'>f2</span>,<span style='color:green'>t3</span>,<span style='color:red'>f4</span> | 2，6     |
          | 【（1，0，3），（1，0，4）】 | <span style='color:red'>f1</span>,<span style='color:green'>t2</span>,<span style='color:red'>f3</span>,<span style='color:green'>t4</span> | 3，7     |
          | 【（1，1，1），（1，1，1）】 | <span style='color:red'>f1</span>,<span style='color:red'>f2</span>,<span style='color:red'>f3</span>,<span style='color:red'>f4</span> | 4，8     |
  
          
  
      - ##### <span style='color:blue'><a name='two_third_six'>路径覆盖</a></span>
  
        - 路径测试就是设计足够的测试用例，覆盖程序中所有可能的路径。
  
      - ##### <span style='color:blue'><a name='two_third_seven'>条件测试路径选择</a></span>
  
        - 当程序中判定多于一个时，形成的分支结构可以分为两类：
  
          1. ##### <span style='color:red'>嵌套型分支结构</span>
  
             ```
             若有n个判定语句，需要n+1个测试用例
             ```
  
          2. ##### <span style='color:red'>连锁型分支结构</span>
  
             ```
             若有n个判定语句，需要有2**n个测试用例，覆盖它的2**n条路经
             ```
  
        - <img src='/图片/7.jpg'>
  
      - ##### <span style='color:blue'><a name='two_third_eight'>循环测试路径选择</a></span>
  
        - 循环分为四种不同类型：
  
          ![1571797430802](\图片\8.png)
  
          1. ##### <span style='color:red'>简单循环</span>
          
             - <span style='color:blue'>零次循环</span>：从循环入口到出口
             - <span style='color:blue'>一次循环</span>：检查循环初始值
             - <span style='color:blue'>二次循环</span>：检查多次循环
     - m次循环：检查在多次循环
             - 最大次数循环、比最大次数多一次、少一次的循环
  
          2. ##### <span style='color:red'>连锁循环</span>
  
             ```
         如果各个循环互相独立，则可以用与简单循环相同的方法进行测试。但如果几个循环不是互相独立的，则需要使用测试嵌套循环的办法来处理
            ```
         
          3. ##### <span style='color:red'>嵌套循环</span>
         
             - 对最内层循环做简单循环的全部测试。所有其他层的循环变量置为最小值
             - 逐步外推，对其外面一层循环进行测试。测试时保持所有外层循环的循环变量取最小值，所有其他嵌套内层循环的循环变量取“典型”值
             - 反复进行，直到所有各层循环测试完毕
             - 对全部各层循环同时取最小循环次数，或者同时取最大循环次数
         
          4. ##### <span style='color:red'>非结构循环</span>
         
             ```
             这一类循环应该使用结构化程序设计方法重新设计测试用例
             ```
        
      - ##### <span style='color:blue'><a name='two_third_nine'>基本路径测试</a></span>
      
        - 基本路径测试方法把覆盖的路径数压缩到一定限度内，<span style='color:red'>**程序中的循环体最多只执行一次**</span>。
        
        - 它是在程序控制流图的基础上，<span style='color:blue'>**分析控制构造的环路复杂性**</span>，导出基本可执行路径集合，设计测试用例的方法。设计出的测试用例要保证在测试中，程序的每一个可执行语句至少要执行一次
        
          1. ##### 程序的控制流图
        
             - 符号O为控制流图的一个结点，表示一个或多个无分支的PDL语句或源程序语句。箭头为边，表示控制流的方向
        
               ![1571798112850](\图片\9.png)
        
             - 在选择或多分枝结构中，分支的汇聚处应有一个汇聚结点
        
             - <span style='color:red'>**边和结点圈定的区域叫做区域**</span>，当对区域计数时，图形外的区域也应记为一个区域
        
             - 如果判断中的条件表达式是由一个或多个逻辑运算符<span style='color:blue'>**（OR,AND）**</span>连接的复合条件表达式，则需改为一系列<span style='color:red'>**只有单个条件的嵌套的判断**</span>。
        
             - ![1571798940897](\图片\10.png)
        
             - ![1571798984288](\图片\11.png)
        
          2. ##### 程序环路复杂性
        
             - 程序的环路复杂行给出了<span style='color:blue'>**程序基本路径集中的独立路径条数**</span>，这是确保程序中每个可执行语句至少执行一次所必须的测试用例数目的上界
             - 从控制流图来看，一条独立路径是至少包含有一条在其他独立路径中从未有过的边的路径
             - 例如，在图示的控制流图中，一组独立的路径是
               1. path1: 1-11
               2. path2: 1-2-3-4-5-10-1-11
               3. path3: 1-2-3-6-8-9-10-1-11
               4. path4: 1-2-3-6-7-9-10-1-11
             - 路径path1,path2,path3,path4组成了控制流图的一个基本路径集
        
          3. ##### 导出测试用例
        
             - 导出测试用例，确保基本路径集中的每一条路径的执行
             - 根据判断结点给出的条件，选择适当的数据以保证某一条路径可以被测试到——用逻辑覆盖方法
             - 每个测试用例执行以后，与预期结果进行比较。如果所有测试用例都执行完毕，则可以确信程序中所有的可执行语句至少被执行了一次
             - 必须注意，一些独立的路径（如例中的路径1），往往不是完全孤立的，有时它是程序正常的控制流的一部分，这时，这些路径的测试可以是另一条路径测试的一部分。
      
    - ##### <a name='two_third_ten'>黑盒测试的测试用例设计</a>
    
      - ##### <a name='two_third_ten_one'>等价类划分</a>
    
        1. 等价类划分是一种典型的黑盒测试方法，使用这一方法时，<span style='color:blue'>**完全不考虑程序的内部结构，只依据程序的规格说明来设计测试用例**</span>
    
        2. 等价类划分方法<span style='color:red'>**把所有可能的输入数据**</span>，即程序的输入域<span style='color:red'>**划分成若干部分**</span>，然后<span style='color:red'>**从每一部分中选取少数有代表性的数据作为测试用例**</span></span>
    
        3. 使用这一方法设计测试用例要经历<span style='color:blue'>**划分等价类**</span>（列出等价类表）和<span style='color:blue'>**选取测试用例**</span>两步
    
        4. <span style='color:red'>**划分等价类**</span>
    
           ```
           等价类是指某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的。测试某等价类的代表值就等价于对这一类其他值的测试
           ```
    
        5. 等价类的划分有两种不同的情况
    
           - <span style='color:blue'>**有效等价类**</span>：
    
             ```
             是指对于程序的规格说明来说，是合理的，有意义的输入数据构成的集合
             ```
    
           - <span style='color:blue'>**无效等价类**</span>：
    
             ```
             是指对于程序的规格说明来说，是不合理的，无意义的输入数据构成的集合
             ```
    
        6. 在设计测试用例时，要同时考虑**有效等价类**和**无效等价类**的设计
    
        7. 划分等价类等价类的原则
    
           - <span style='color:red'>**如果输入条件规定了取值范围，或值的个数，则可以确立一个有效等价类和两个无效等价类**</span>
    
             ##### 例如：
    
             在程序的规格说明中，对输入条件有一句话：
    
             ```
             “...项数可以从1到999...”
             ```
    
             分析：
    
             ```
             有效等价类是"1<=项数<=999"
             两个无效等价类是“项数<1” 或 “项数>999”。 在数轴上表示成
             ```
    
             ![1571802483752](\图片\12.png)
    
             
    
           - 如果输入条件规定了输入值的集合，或者是规定了输入值的集合，或者是规定了“<span style='color:blue'>**必须如何**</span>”的条件，这时可确立一个有效等价类和一个无效等价类
    
           - <span style='color:red'>**如果输入条件是一个布尔量，则可以确定一个有效等价类和一个无效等价类**</span>
    
           - <span style='color:red'>**如果规定了输入数据的一组值，而且程序要对每个输入值分别进行处理。**</span>这时可为每一个输入值确立一个有效等价类，此外针对这组值确立一个无效等价类，它是所有不允许的输入值的集合
    
             ##### 例如：
    
             ````
           在教师上岗方案中规定对教授、副教授、讲师和助教分别计算分数，做相应的处理。因此可以确定4个有效等价类为教授、副教授、讲师和助教，一个无效等价类，它是所有不符合以上身份的人员的输入值的集合
             ````
      
           - <span style='color:red'>**如果规定了输入数据必须遵守的规则，则可以确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）**</span>
      
             ##### 例如：
      
             ```
             Pascal语言规定“一个语句必须以分号结束”。这时，可以确定一个有效等价类“以分号结束”，若干个无效等价类“不以分号结尾”
             ```
      
           - <span style='color:red'>**确立测试用例**</span>
      
             ![1571819955027](\图片\13.png)
      
           - 再从划分出的等价类中按以下原则选择测试用例：
      
             1. 为每一个等价类规定一个唯一编号
      
             2. 设计一个新的测试用例，使其<span style='color:blue'>**尽可能地覆盖尚未被覆盖的有效等价类**</span>，重复这一步，直到所有的有效等价类都被覆盖为止
      
             3. 设计一个新的测试用例，使其<span style='color:blue'>**仅覆盖一个尚未被覆盖的无效等价类**</span>，重复这一步，直到所有的无效等价类都被覆盖为止
      
             4. 用等价类划分法设计测试用例的实例:
      
                ```
                在某一PASCAL语言版本中规定：
                “标识符是由字母开头，后跟字母或数字的任意组合构成。有效字符数为8个，最大字符数为80个”。并且规定“标识符必须先说明，在使用” “在同一说明语句中，标识符至少必须有一个”
                ```
      
                用等价类划分法，建立输入等价类表：
      
                ![1571821206137](C:\Users\EDZ\Desktop\测试\图片\14.png)
      
      - ##### <a name='two_third_ten_two'>边界值分析</a>
      
        - 边界值分析也是一种黑盒测试方法，是对等价类划分方法的补充
      
        - 人们从长期的测试工作经验得知，<span style='color:blue'>**大量的错误是发生在输入或输出范围的边界上，而不是在输入范围的内部**</span>。因此针对各种边界情况设计测试用例，可以查出更多的错误
      
        - 比如，在做三角形计算时，要输入三角形的三个边长：A、B和C。我们应注意到这三个数值应当满足
      
          ```
          A>0 , B>0 , C>0
          A+B>C , A+C>B , B+C>A
          ```
      
          才能构成三角形。但如果把六个不等式中的任何一个大于号错写成大于等于号，那就不能构成三角形。问题恰出现在容易被疏忽的边界附近
      
        - 这里所说的边界是指，相当于输入等价类和输出等价类而言，稍高于其边界值及稍低于其边界值的一些特定情况
      
        - 使用边界值分析方法设计测试用例，首先应确定边界情况。<span style='color:red'>**应当选取正好等于，刚刚大于，或刚刚小于边界的值作为测试数据**</span>，而不是选取等价类中的典型值或任意值作为测试数据
      
      - ##### <a name='two_third_ten_three'>错误推测法</a>
      
        - 人们也可以靠经验和直觉推测程序中可能存在的各种错误，从而有针对性地编写检查这些错误的例子。这就是错误推测法
        - 错误推测法的基本想法是：<span style='color:red'>**列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据它们选择测试用例**</span>
      
      - ##### <a name='two_third_ten_four'>因果图</a>
      
        - ##### 因果图的适用范围
      
          ```
          如果在测试时必须考虑输入条件的各种组合，可使用一种适合于描述对于多种条件的组合，相应产生多个动作的形式来设计测试用例，这就需要利用因果图。
          因果图方法最终生成的就是判定表。它适合于检查程序输入条件的各种组合情况。
          ```
      
        - ##### 用因果图生成测试用例的基本步骤
      
          1. 分析软件规格说明描述中，哪些是原因（即输入条件或输入条件的等价类），哪些是结果（即输出条件），并给每个原因和结果赋予一个标识符
          2. 分析软件规格说明描述中的语义，找出原因与结果之间，原因与原因之间对应的是什么关系？根据这些关系画出因果图
          3. 由于语法或环境限制，有些原因与原因之间，原因与结果之间的组合情况不可能出现。为标明这些特殊情况，在因果图上用一些记号标明约束或限制条件
          4. 把因果图转换成判定表
          5. 把判定表的每一列拿出来作为依据，设计测试用例
      
        - ##### 在因果图中出现的基本符号
      
          ```
          通常在因果图中用Ci表示原因，用Ei表示结果，各节点表示状态，可取值“0”或“1”.“0”表示某状态不出现，“1”表示某状态出现
          ```
      
        - ##### 主要的原因和结果之间的关系有：
      
          ![1571824619416](\图片\15.png)
      
        - ##### 表示约束条件符号
      
          ```
          为了表示原因与原因之间、结果与结果之间可能存在的约束条件，在因果图中可以附加一些表示约束条件的符号。
          ```
      
          ![1571824709522](\图片\16.png)
      
        - ##### 例如：
      
          ```
          有一个处理单价为5角钱的饮料的自动售货机软件测试用例的设计。其规格说明如下：
          
          若投入5角钱或一元钱的硬币，押下【橙汁】或【啤酒】的按钮，则相应的饮料就送出来。若售货机没有零钱找，则一个显示【零钱找完】的红灯亮，这时再投入1元硬币并押下按钮后。饮料不送出来而且1元硬币也退出来；若有零钱找，则显示【零钱找完】的红灯灭，在送出饮料的同时退还5角硬币
          ```
      
          - <span style='color:red'>**分析这一段说明，列出原因和结果**</span>
      
            - ##### 原因：
      
              1. 售货机有零钱找
              2. 投入1元硬币
              3. 投入5角硬币
              4. 押下橙汁按钮
              5. 押下啤酒按钮
      
            - ##### 建立中间结点，表示处理中间状态：
      
              11. 投入1元硬币且押下饮料按钮
      
              12. 押下橙汁或啤酒的按钮
      
              13. 应当找5角钱并且售货机有零钱找
      
              14. 钱已付清
      
            - ##### 结果：
      
              21. 售货机【零钱找完】灯亮
      
              22. 退还1元硬币
      
              23. 退还5角硬币
      
              24. 送出橙汁饮料
      
              25. 送出啤酒饮料
      
          - ##### <span style='color:red'>画出因果图</span>
      
            ```
            所有原因结点列在左边，所有结果结点列在右边
            ```
      
          - 由于2与3，4与5并不能同时发生
      
            ##### <span style='color:red'>分别加上约束条件E</span>
      
          - ##### <span style='color:red'>因果图</span>
      
          - ##### <span style='color:red'>转换成判定表</span>
      
            ![1571825547176](\图片\17.png)
      
            
      
            ![1571825574553](\图片\18.png)
  